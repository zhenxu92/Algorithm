/**
 * DirectedGraphCreater Version 1.0(a)
 * @author zhenxu
 * This program takes in your directed graph instruction data,
 * and then put it into an adjacent matrix form. It performs the
 * transpose of the matrix in order to find the inverse directed
 * graph.
 */

import java.util.*;

public class DirectedGraphCreater {
	// data field
	private int[][] adjMat;	// adjacentMatrix

	// TODO: need a data structure to store the graph data, then construct it
	/**
	 * Constructor: initiate the length of adjacent matrix
	 * @param numOfVertex the total number of vertices in the graph
	 */
	public DirectedGraphCreater(int numOfVertex) {
		adjMat = new int[numOfVertex + 1][numOfVertex + 1];
	}
	
	/**
	 * This method takes in a start vertex and an end vertex and
	 * create an edge between these two vertices by marking it in
	 * the adjacent matrix.
	 * @param start the index notation of the start vertex
	 * @param end the index notation of the end vertex
	 */
	public void makeEdge(int start, int end) {
		this.adjMat[start][end] = 1;
	}
	
	/**
	 * This method takes the adjacent matrix and transpose it, in other words,
	 * inverse directions of all the edges.
	 * @return the graph with inverse edges
	 */
	public int[][] transpose() {
		int length = this.adjMat[0].length;
		int[][] adjMatT = new int[length][length];
		return adjMatT;
	}
	
	public void printMat(int[][] mat) {
		int length = this.adjMat[0].length;
		System.out.println("The adjacency matrix for the graph is");
		System.out.println();
		for (int i = 1; i < length; i++) {
			System.out.println(i + " ");
		}
		System.out.println();
		for (int i = 1; i < length; i++) {
			System.out.print(i + " ");
			for (int j = 1; j < length; j++) {
				System.out.print(this.adjMat[i][j] + " ");
			}
			System.out.println();
		}
	}
}
